<HTML>
<HEAD><TITLE>Buttons</TITLE>
<SCRIPT type="text/javascript">
//----------------------------------------------------------------------------
/*
*/
function handleFileSelect(evt) {
   var files = evt.target.files; // FileList object

    // files is a FileList of File objects. List some properties.
   var output = [];
   ouput.push(files.size);
    for (var i = 0, f; f = files[i]; i++) {
      output.push('<li><strong>', escape(f.name), '</strong> (', f.type || 'n/a', ') - ',
                  f.size, ' bytes, last modified: ',
                  f.lastModifiedDate ? f.lastModifiedDate.toLocaleDateString() : 'n/a',
                  '</li>');
    }
  document.getElementById('files_list').innerHTML = '<ul>' + output.join('') + '</ul>';
}
//----------------------------------------------------------------------------
function handleButtonClick(evt) {
   var files = evt.target.files; // FileList object
  alert (document.getElementById('files_list').nodeValue)
}
  document.getElementById('files').addEventListener('change', handleFileSelect, false);
  document.getElementById('file_btn').addEventListener('change', handleButtonClick, false);
//----------------------------------------------------------------------------
function HandleBrowseClick()
{
    var fileinput = document.getElementById("browse");
    fileinput.click();
}
//----------------------------------------------------------------------------
function Handlechange()
{
  var fileinput = document.getElementById("browse");
  var textinput = document.getElementById("filename");
  textinput.value = fileinput.value;
}
//----------------------------------------------------------------------------
function set_radio_value(form, value)
{
  var f;

  for (var i=0; i < form.length; i++) {
    f = form[i].value == parseInt(value);
    form[i].checked = f;
  }
}
//----------------------------------------------------------------------------
var slurmConfigDefault = {};

slurmConfigDefault["ControlMachine"] = "control_addr";
slurmConfigDefault["BackupController"] = "backup_controller";
slurmConfigDefault["ControlAddr"] = ["control_addr"];
slurmConfigDefault["BackupController"] = ["backup_controller"];
slurmConfigDefault["BackupAddr"] = ["backup_addr"];
slurmConfigDefault["AuthType"] = "";
slurmConfigDefault["CheckpointType"] = "";
slurmConfigDefault["CryptoType"] = "crypto_type";

//----------------------------------------------------------------------------
function download(filename, text) {
    var pom = document.createElement('a');
    pom.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    pom.setAttribute('download', filename);

    if (document.createEvent) {
        var event = document.createEvent('MouseEvents');
        event.initEvent('click', true, true);
        pom.dispatchEvent(event);
    }
    else {
        pom.click();
    }
}
//----------------------------------------------------------------------------
function getSlurmConfigText()
{
  var printme = "# slurm.conf file generated by configurator.html.\n" +
   "# Put this file on all nodes of your cluster.\n" +
   "# See the slurm.conf man page for more information.\n" +
   "#\n" +
   "ControlMachine=" + document.config.control_machine.value + "\n" +
   get_field("ControlAddr",document.config.control_addr) + "\n";// +
/*
   get_field("BackupController",document.config.backup_controller) + "<br>" +
   get_field("BackupAddr",document.config.backup_addr) + "<br>" +
   "# <br>" +
   "AuthType=auth/" + get_radio_value(document.config.auth_type) + "<br>" +
   "#CheckpointType=checkpoint/none <br>" +
   "CryptoType=crypto/" + get_radio_value(document.config.crypto_type) + "<br>" +
   "#DisableRootJobs=NO <br>" +
   "#EnforcePartLimits=NO <br>" +
   get_field("Epilog",document.config.epilog) + "<br>" +
   "#EpilogSlurmctld= <br>" +
   "#FirstJobId=1 <br>" +
   "#MaxJobId=999999 <br>" +
   "#GresTypes= <br>" +
   "#GroupUpdateForce=0 <br>" +
   "#GroupUpdateTime=600 <br>" +
   "#JobCheckpointDir=/var/slurm/checkpoint <br>" +
   get_field("JobCredentialPrivateKey", document.config.private_key) + "<br>" +
   get_field("JobCredentialPublicCertificate", document.config.public_key) + "<br>" +
   "#JobFileAppend=0 <br>" +
   "#JobRequeue=1 <br>" +
   "#JobSubmitPlugins=1 <br>" +
   "#KillOnBadExit=0 <br>" +
   "#LaunchType=launch/slurm <br>" +
   "#Licenses=foo*4,bar <br>" +
   "#MailProg=/bin/mail <br>" +
   "#MaxJobCount=5000 <br>" +
   "#MaxStepCount=40000 <br>" +
   "#MaxTasksPerNode=128 <br>" +
   "MpiDefault=" + get_radio_value(document.config.mpi_default) + "<br>" +
   "#MpiParams=ports=#-# <br>" +
   "#PluginDir= <br>" +
   "#PlugStackConfig= <br>" +
   "#PrivateData=jobs <br>" +
   "ProctrackType=proctrack/" + get_radio_value(document.config.proctrack_type) + "<br>" +
   get_field("Prolog",document.config.prolog) + "<br>" +
   "#PrologFlags= <br>" +
   "#PrologSlurmctld= <br>" +
   "#PropagatePrioProcess=0 <br>" +
   "#PropagateResourceLimits= <br>" +
   "#PropagateResourceLimitsExcept= <br>" +
   "#RebootProgram= <br>" +
   "ReturnToService=" + get_radio_value(document.config.return_to_service) + "<br>" +
   "#SallocDefaultCommand= <br>" +
   "SlurmctldPidFile=" + document.config.slurmctld_pid_file.value + "<br>" +
   "SlurmctldPort=" + document.config.slurmctld_port.value + "<br>" +
   "SlurmdPidFile=" + document.config.slurmd_pid_file.value + "<br>" +
   "SlurmdPort=" + document.config.slurmd_port.value + "<br>" +
   "SlurmdSpoolDir=" + document.config.slurmd_spool_dir.value + "<br>" +
   "SlurmUser=" + document.config.slurm_user.value + "<br>" +
   "#SlurmdUser=root <br>" +
   get_field("SrunEpilog",document.config.srun_epilog) + "<br>" +
   get_field("SrunProlog",document.config.srun_prolog) + "<br>" +
   "StateSaveLocation=" + document.config.state_save_location.value + "<br>" +
   "SwitchType=switch/" + get_radio_value(document.config.switch_type) + "<br>" +
   get_field("TaskEpilog",document.config.task_epilog) + "<br>" +
   "TaskPlugin=task/" + get_radio_value(document.config.task_plugin) + "<br>" +
   get_task_plugin_param() + "<br>" +
   get_field("TaskProlog",document.config.task_prolog) + "<br>" +
   "#TopologyPlugin=topology/tree <br>" +
   "#TmpFS=/tmp <br>" +
   "#TrackWCKey=no <br>" +
   "#TreeWidth= <br>" +
   "#UnkillableStepProgram= <br>" +
   "#UsePAM=0 <br>" +
   "# <br>" +
   "# <br>" +
   "# TIMERS <br>" +
   "#BatchStartTimeout=10 <br>" +
   "#CompleteWait=0 <br>" +
   "#EpilogMsgTime=2000 <br>" +
   "#GetEnvTimeout=2 <br>" +
   "#HealthCheckInterval=0 <br>" +
   "#HealthCheckProgram= <br>" +
   "InactiveLimit=" + document.config.inactive_limit.value + "<br>" +
   "KillWait=" + document.config.kill_wait.value + "<br>" +
   "#MessageTimeout=10 <br>" +
   "#ResvOverRun=0 <br>" +
   "MinJobAge=" + document.config.min_job_age.value + "<br>" +
   "#OverTimeLimit=0 <br>" +
   "SlurmctldTimeout=" + document.config.slurmctld_timeout.value + "<br>" +
   "SlurmdTimeout=" + document.config.slurmd_timeout.value + "<br>" +
   "#UnkillableStepTimeout=60 <br>" +
   "#VSizeFactor=0 <br>" +
   "Waittime=" + document.config.wait_time.value + "<br>" +
   "# <br>" +
   "# <br>" +
   "# SCHEDULING <br>" +
   "#DefMemPerCPU=0 <br>" +
   "FastSchedule=" + get_radio_value(document.config.fast_schedule) + "<br>" +
   "#MaxMemPerCPU=0 <br>" +
   "#SchedulerTimeSlice=30 <br>" +
   "SchedulerType=sched/" + get_radio_value(document.config.sched_type) + "<br>" +
   "SelectType=select/" + get_radio_value(document.config.select_type) + "<br>" +
   get_select_type_params() + "<br>" +
   "# <br>" +
   "# <br>" +
   "# JOB PRIORITY <br>" +
   "#PriorityFlags= <br>" +
   "#PriorityType=priority/basic <br>" +
   "#PriorityDecayHalfLife= <br>" +
   "#PriorityCalcPeriod= <br>" +
   "#PriorityFavorSmall= <br>" +
   "#PriorityMaxAge= <br>" +
   "#PriorityUsageResetPeriod= <br>" +
   "#PriorityWeightAge= <br>" +
   "#PriorityWeightFairshare= <br>" +
   "#PriorityWeightJobSize= <br>" +
   "#PriorityWeightPartition= <br>" +
   "#PriorityWeightQOS= <br>" +
   "# <br>" +
   "# <br>" +
   "# LOGGING AND ACCOUNTING <br>" +
   "#AccountingStorageEnforce=0 <br>" +
   get_field("AccountingStorageHost",document.config.accounting_storage_host) + "<br>" +
   get_field("AccountingStorageLoc",document.config.accounting_storage_loc) + "<br>" +
   get_field("AccountingStoragePass",document.config.accounting_storage_pass) + "<br>" +
   get_field("AccountingStoragePort",document.config.accounting_storage_port) + "<br>" +
   "AccountingStorageType=accounting_storage/" + get_radio_value(document.config.accounting_storage_type) + "<br>" +
   get_field("AccountingStorageUser",document.config.accounting_storage_user) + "<br>" +
   get_field("AccountingStoreJobComment",document.config.acctng_store_job_comment) + "<br>" +
   get_field("ClusterName",document.config.cluster_name) + "<br>" +
   "#DebugFlags= <br>" +
   get_field("JobCompHost",document.config.job_comp_host) + "<br>" +
   get_field("JobCompLoc",document.config.job_comp_loc) + "<br>" +
   get_field("JobCompPass",document.config.job_comp_pass) + "<br>" +
   get_field("JobCompPort",document.config.job_comp_port) + "<br>" +
   "JobCompType=jobcomp/" + get_radio_value(document.config.job_comp_type) + "<br>" +
   get_field("JobCompUser",document.config.job_comp_user) + "<br>" +
   "#JobContainerType=job_container/none <br>" +
   get_field("JobAcctGatherFrequency",document.config.job_acct_gather_frequency) + "<br>" +
   "JobAcctGatherType=jobacct_gather/" + get_radio_value(document.config.job_acct_gather_type) + "<br>" +
   "SlurmctldDebug=" + document.config.slurmctld_debug.value + "<br>" +
   get_field("SlurmctldLogFile",document.config.slurmctld_logfile) + "<br>" +
   "SlurmdDebug=" + document.config.slurmd_debug.value + "<br>" +
   get_field("SlurmdLogFile",document.config.slurmd_logfile) + "<br>" +
   "#SlurmSchedLogFile= <br>" +
   "#SlurmSchedLogLevel= <br>" +
   "# <br>" +
   "# <br>" +
   "# POWER SAVE SUPPORT FOR IDLE NODES (optional) <br>" +
   "#SuspendProgram= <br>" +
   "#ResumeProgram= <br>" +
   "#SuspendTimeout= <br>" +
   "#ResumeTimeout= <br>" +
   "#ResumeRate= <br>" +
   "#SuspendExcNodes= <br>" +
   "#SuspendExcParts= <br>" +
   "#SuspendRate= <br>" +
   "#SuspendTime= <br>" +
   "# <br>" +
   "# <br>" +
   "# COMPUTE NODES <br>" +
   "NodeName=" + document.config.node_name.value +
   get_field2(" NodeAddr",document.config.node_addr) +
   get_field2(" CPUs",document.config.procs) +
   get_field2(" RealMemory",document.config.memory) +
   get_field2(" Sockets",document.config.sockets) +
   get_field2(" CoresPerSocket",document.config.cores_per_socket) +
   get_field2(" ThreadsPerCore",document.config.threads_per_core) +
   " State=UNKNOWN <br>" +
   "PartitionName=" + document.config.partition_name.value +
   " Nodes=" + document.config.node_name.value +
   " Default=YES"+
   " MaxTime=" + document.config.max_time.value +
   " State=UP"
*/

   //scroll(0,0);
   //var popup = document.getElementById('out_box');

   //popup.innerHTML = "<a href='javascript:hide_box();'>close</a><br>";
   //popup.innerHTML += "#BEGIN SLURM.CONF FILE<br><br>";
   //popup.innerHTML += printme;
   //popup.innerHTML += "<br><br>#END SLURM.CONF FILE<br>";
   //popup.innerHTML += "<a href='javascript:hide_box();'>close</a>";

   //popup.style.visibility = 'visible';

   // OLD CODE
   return (printme);
/*
   document.open();
   document.write(printme);
   document.close();
*/
}
//----------------------------------------------------------------------------
function saveDoc ()
{
	try {
		download("debug_js.txt", getSlurmConfigText());
	}
	catch (e) {
		alert (e);
	}
}
//----------------------------------------------------------------------------
function addDocFromFile()
{
	document.getElementById('myFile').click();
//	addDoc();
}
//----------------------------------------------------------------------------
function addDoc()
{
	var file=document.getElementById("myFile").files[0]; //for input type=file
	var reader = new FileReader();
/**/
	var cfg = {};

	cfg["ControlMachine"] = "control_addr";
	cfg["BackupController"] = "backup_controller";

	var n, cfg_len, str;
	cfg_len = Object.keys(cfg).length;
	str = Object.keys(cfg).length.toString() + "<br>";
	try {
		for (n=0 ; n < cfg_len ; n++) {
			strKey = Object.keys(cfg)[n];
			str += cfg[strKey] + "<br>";
//			str += cfg[cfg[n]] + "<br>";
		}
	}
	catch (e) {
		str = document.getElementById("DisplayText").innerHTML;
	}
	document.getElementById("DisplayText").innerHTML = str;
/**/

// If we use onloadend, we need to check the readyState.
	reader.onloadend = function(evt) {
		if (evt.target.readyState == FileReader.DONE) { // DONE == 2
			lines = evt.target.result;

			try {
				var str, strCell, strHtml, strName;
				var arr = new Uint8Array(lines);
				strName = strCell = "";
				strHtml='<table border="2" style="table-layout:fixed;" width="80%"><tr>';
				str = String.fromCharCode.apply(String, arr);
				for (var n=0 ; n < str.length ; n++) {
					if (str[n] == "=") {
						if (strCell.trim() == "ControlMachine") {
							strName = "control_machine";
						}
						else if (strCell.trim() == "ReturnToService") {
							strName = "return_to_service";
						}
						strCell = "";
					}
					else if (str.charCodeAt(n) == 13) { // new line
						if (strName == "control_machine") {
							document.getElementsByName(strName)[0].value = strCell;
						}
						else if (strName == "return_to_service") {
							set_radio_value(document.getElementsByName(strName), strCell)
/*
                var f, frm = document.getElementsByName(strName);//[0];//.checked = 1;
                for (var i=0 ; i < frm.length ; i++) {
                  f = (frm[i].value == parseInt(strCell));
                  frm[i].checked = f;
                }
*/
						}
						strHtml += "</tr>" + strCell + "</td><tr>";
						strCell = "";
						strName = "";
						lines++;
					}
					else {
						strCell += str[n];
					}
				}
				strHtml += "</tr></table>";
			}
			catch (e) {
				alert (e);
			}
		}
	}

//  reader.readAsText(file);
  reader.readAsArrayBuffer(file);
}
//----------------------------------------------------------------------------
</SCRIPT>
<!-- <div style='visibility:hidden;text-align:left;background:#ccc;border:1px solid black;position: absolute;left:100;z-index:1;padding:5;' id='out_box'></div> -->
</HEAD>
<BODY onload>
<FORM name=config>
<table border="0" style="width:100%;">
  <tr>
	<td><input type="button" id="loadFile" value="Load File..." onclick="addDocFromFile()" /></td>
    <td align="center"><button type="button" id="btnSave"   onclick="saveDoc()">Save</button></td>
    <td align="center"><button type="button" id="btnSaveAs" onclick="alert('Save As')">Save As...</button></td>
  </tr>
</table>

<input style="display:none;" type="file" id="myFile" onchange="addDoc()">
<button type="button" onclick="addDoc()">Add Document</button>
<p id="DisplayText"></p>

<H2>Authentication and Security</H2>
Define the method used for authenticating communicating between Slurm components.<BR>
Select one value for <B>AuthType</B>:<BR>
<input type="radio" name="auth_type" value="none"> <B>None</B>: No authentication. Not recommended for production use.<br>
<input type="radio" name="auth_type" value="munge" checked> <B>Munge</B>: LLNL's <A href="http://home.gna.org/munge/">Munge</A><BR>

<H2>Control Machines</H2>
Define the hostname of the computer on which the Slurm controller and
optional backup controller will execute. You can also specify addresses
of these computers if desired (defaults to their hostnames).
The IP addresses can be either numeric IP addresses or names.
Hostname values should not be the fully qualified domain
name (e.g. use <I>tux</I> rather than <I>tux.abc.com</I>).
<P>
<input type="text" name="control_machine" id = "17" value="linux0"> <B>ControlMachine</B>:
Master Controller Hostname
<P>
<input type="text" name="control_addr"> <B>ControlAddr</B>: Master Controller
Address (optional)
<P>
<input type="text" name="backup_controller"> <B>BackupController</B>: Backup
Controller Hostname (optional)
<P>
<input type="text" name="backup_addr"> <B>BackupAddr</B>: Backup Controller
Address (optional)
<P>

  <H2>State Preservation</H2>
  Define the location of a directory where the slurmctld daemon saves its state.
  This should be a fully qualified pathname which can be read and written to
  by the Slurm user on both the control machine and backup controller (if configured).
  The location of a directory where slurmd saves state should also be defined.
  This must be a unique directory on each compute server (local disk).
  The use of a highly reliable file system (e.g. RAID) is recommended.
  <P>
  <input type="text" name="state_save_location" value="/var/spool"> <B>StateSaveLocation</B>:
  Slurmctld state save directory <B>Must be writable by both ControlMachine and BackupController</B>
  <P>
  <input type="text" name="slurmd_spool_dir" value="/var/spool/slurmd"> <B>SlurmdSpoolDir</B>:
  Slurmd state save directory
  <P>
  Define when a non-responding (DOWN) node is returned to service.<BR>
  Select one value for <B>ReturnToService</B>:<BR>
  <input type="radio" name="return_to_service" value="0">
  <B>0</B>: When explicitly restored to service by an administrator.<BR>
  <input type="radio" name="return_to_service" value="1" checked>
  <B>1</B>:Upon registration with a valid configuration only if it was set DOWN
  due to being non-responsive.<BR>
  <input type="radio" name="return_to_service" value="2">
  <B>2</B>:Upon registration with a valid configuration.<BR>
  <P>
  
    <div id="file_content"></div>

</FORM>

</BODY>
